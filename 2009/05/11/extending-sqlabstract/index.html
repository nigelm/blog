<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0">


  
    <meta name="description" content="Most of the perl I write currently has ties into DBIx::Class and hence uses SQL::Abstract.
I also have far too much of a preference for boolean items, which I normally encode in the database as a column of type boolean (or the SQLite vague equivalent).
Its been fairly easy to encode a test for boolean value being true with SQL::Abstract - although the syntax
column =&gt; \&#39;&#39;  which maps to">
  







  <meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://nigelm.github.io/blog/images/og-featured.png"/>

<meta name="twitter:title" content="Extending SQL::Abstract"/>
<meta name="twitter:description" content="Most of the perl I write currently has ties into DBIx::Class and hence uses SQL::Abstract.
I also have far too much of a preference for boolean items, which I normally encode in the database as a column of type boolean (or the SQLite vague equivalent).
Its been fairly easy to encode a test for boolean value being true with SQL::Abstract - although the syntax
column =&gt; \&#39;&#39;  which maps to"/>



<meta name="generator" content="Hugo 0.69.0" />
  <title>Extending SQL::Abstract | Nailing Jelly</title>
  <link rel="canonical" href="/blog/2009/05/11/extending-sqlabstract/">


  








  
    
  
  
  <link rel="stylesheet" href="/blog/css/base.min.7755190cce20b9fe1580b4b0c873dbe27e696d55f7f754a4b68d58afad7817d7.css" integrity="sha256-d1UZDM4guf4VgLSwyHPb4n5pbVX391Skto1Yr614F9c=" crossorigin="anonymous">



</head>

<body>
  <nav class="u-background">
  <div class="u-wrapper">
    <ul class="Banner">
      <li class="Banner-item Banner-item--title">
        <a class="Banner-link u-clickable" href="/blog/">Nailing Jelly</a>
      </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/blog/about/">About</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/blog/posts/">Posts</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/blog/tags/">Tags</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/blog/categories/">Categories</a>
        </li>
      
        <li class="Banner-item">
          <a class="Banner-link u-clickable" href="/blog/index.xml">RSS</a>
        </li>
      
    </ul>
  </div>
</nav>
  <main>
    <div class="u-wrapper">
      <div class="u-padding">
        

  <article>
    <header class="Heading">
  <h2 class="Heading-title">
    <a class="Heading-link u-clickable" href="/blog/2009/05/11/extending-sqlabstract/" rel="bookmark">Extending SQL::Abstract</a>
  </h2>
  
    <time datetime="2009-05-11T19:48:28Z">11 May, 2009</time>
  
</header>
    <p>Most of the perl I write currently has ties into <a href="http://search.cpan.org/perldoc?DBIx::Class">DBIx::Class</a> and hence uses <a href="http://search.cpan.org/perldoc?SQL::Abstract">SQL::Abstract</a>.</p>
<p>I also have far too much of a preference for boolean items, which I normally encode in the database as a column of type boolean (or the <a href="http://sqlite.org/">SQLite</a> vague equivalent).</p>
<p>Its been fairly easy to encode a test for boolean value being true with SQL::Abstract - although the syntax</p>
<pre><code>column =&gt; \''
</code></pre>
<p>which maps to</p>
<pre><code>WHERE column
</code></pre>
<p>is a little esoteric.  However its downright close to impossible to produce the opposite test without using literal SQL (actually the first version uses literal SQL - except the SQL statement is NULL and comes <em>after</em> the column reference).</p>
<p>So today I have spent a little time extending SQL::Abstract to support the -bool and -not_bool unary operators which allow both positive and negative boolean tests to be encoded in a way that does not resort to literal SQL.</p>
<p>As part of this I refactored a part of SQL::Abstract so that further extensions of this type can be added more easily - adding a unary_ops extension to the constractor in the same way as the previously existing special_ops.</p>
<p>So now:-</p>
<pre><code>-bool      =&gt; this_column,
-not_bool  =&gt; that_column
</code></pre>
<p>will map to</p>
<pre><code>WHERE this_column AND NOT that_column
</code></pre>
<p>The code for this is currently sitting in a <a href="http://dev.catalyst.perl.org/svnweb/bast/browse/SQL-Abstract/1.x/branches/bool_operator/">svn branch</a> - please have a look and comment on this.  My own criticism of it is that the syntax is clunky, but we are restricted to the perl datastructure mapping approach of the existing code (which is the real <em>raison d&rsquo;etre</em> of SQL::Abstract).</p>

    


  

  





  <footer>
    
      
        <ul class="Tags">
          
            <li class="Tags-item u-background">
              <a class="Tags-link u-clickable" href="/blog/categories/perl/" rel="tag">perl</a>
            </li>
          
        </ul>
      
    
      
    
  </footer>

    
  

  </article>


      </div>
    </div>
  </main>
  
  <footer class="Footer">
    <div class="u-wrapper">
      <div class="u-padding">
        Except where otherwise noted, content on this site is licensed under a &#32; <a href="http://creativecommons.org/licenses/by/4.0/" rel="license">Creative Commons Attribution 4.0 International License</a>.
      </div>
    </div>
  </footer>

</body>

</html>
